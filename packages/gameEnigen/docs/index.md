# 游戏引擎说明文档


### 坐标系说明
GLSL 中，mat4 是按照列的顺序加载矩阵的。

```js
const mt4 = mat4(  1, 2, 3, 4, 
                   5, 6, 7, 8, 
                   9,10,11,12, 
                  13,14,15,16 )

// 等价与
const mt4 = [
  1,5, 9,13,
  2,6,10,14,
  3,7,11,15,
  4,8,12,16
]

mt4[0].x // 1 
mt4[0].z // 3 
mt4[1].w // 8
mt4[2].y // 10 

```

##### 矩阵右乘矢量  
gl_Position = projMt * vec4(a_position, 1.0);

```js
// 咱们继续复用上面的mt4来进行计算
mt4 * [x,y,z,w]

const newX = mt4[0].x*x + mt4[1].x*y + mt4[2].x*z + mt4[3].x*w
const newY = mt4[0].y*x + mt4[1].y*y + mt4[2].y*z + mt4[3].y*w
...

```


##### 矩阵左乘矢量
gl_Position = vec4(a_position, 1.0) * projMt;

```js
[x,y,z,w] * mt4

const newX = x*mt4[0].x + y*mt4[0].y + z*mt4[0].z + w*mt4[0].w
const newY = x*mt4[1].x + y*mt4[1].y + z*mt4[1].z + w*mt4[1].w
...

```

从上面可以看出，如果我们传入的 uniform mat4 变量是正常的矩阵顺序，mat4构造函数会将这个矩阵转置，所以从感觉上会出现错觉。
这时，我们只需使用矩阵左乘矢量，这样就相当于在计算时又将矩阵转置了一次，得到认知上的计算结果。

points * projMt

```js
vec4(x, y, z, 1) * mat4(r/w,    0,   0, -1,
                          0, -r/h,   0,  1,
                          0,    0, 1/d,  0,
                          0,    0,   0,  1  )

// 上面的计算，等价于下面的矩阵乘以矢量的结果

[ r/w,  0,   0, -1,
  0, -r/h,   0,  1,
  0,    0, 1/d,  0,
  0,    0,   0,  1 ]  * [x, y, z, 1]

const newX = x*r/w + 0*y + 0*z -1 = x*r/w - 1
const newY = 0*x -y*r/h + 0*z + 1 = 1 - y*r/h
const newZ = 0*x + 0*y + z/d + 0  = z/d
const newW = 1
```
                  
##### 矩阵与矩阵相乘  

```js
mat3(1, 2, 3, 
     4, 5, 6, 
     7, 8, 9 ) * mat3(a, b, c, 
                      d, e, f, 
                      x, y, z ) 

// 先进行数据行列转置，变换成两个矩阵，然后再进行计算
| 1, 4, 7 |     | a, d, x |     |  a+4b+7c,  d+4e+7f,  x+4y+7z |
| 2, 5, 8 |  *  | b, e, y |  =  | 2a+5b+8c, 2d+5e+8f, 2x+5y+8z |
| 3, 6, 9 |     | c, f, z |     | 3a+6b+9c, 3d+6e+9f, 3x+6y+9z |

// 上面矩阵相乘计算得出新的矩阵后，还需再进行转置，存入新的mat3 变量中。

mat3 mtc = (a+4b+7c, 2a+5b+8c, 3a+6b+9c, d+4e+7f, 2d+5e+8f, 3d+6e+9f,)

```

总之，就是GLSL中，mat矩阵变量，都是按照转置后的矩阵读取和存储的。


###### 世界地图坐标  

假如我们定义这个世界地图有 10000 * 20000 的矩形地图

主摄像机的坐标点在 (1000, 5000) 这个地方，会一直处于视口中心点位置。设定可视区域有 1000 * 2100 这么大

(1000-500,5000-1050) ~ (1000+500, 5000+1050) 这个范围是需要渲染到屏幕上的

下面需要将这个范围内的坐标点，转化为webgl坐标系上的点



