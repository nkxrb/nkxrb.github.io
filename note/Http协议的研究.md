### HTTP1.0

- 只能与服务器保持短暂的连接，每次请求都需要与服务器建立一个 TCP 连接，完成后会立即断开

- 对头阻塞，下一个请求必须在前一个请求响应到达后才能发送

### HTTP1.1

- 支持长连接， 增加了一个 Connection：keep-Alive 连接可复用
- 请求管道化，实际使用起来存在各种各样的问题，因此很多浏览器都没支持这个特性
- 我们平时看到的并行加载，其实是浏览器为了提高资源加载效率，在同域名下开启了 6-8 个 tcp 连接进行并行下载。
- 缓存处理机制，（强缓存和协商缓存）
- 支持断点传输
- 增加了 host 字段，使得同一台服务器能够用来创建多个 web 站点

### HTTP2.0

- 支持并发，多路复用
- 头部压缩
- 服务器主动推送，无需客户端明确的请求

### 浏览器的缓存策略

浏览器缓存分为本地缓存（强缓存），协商缓存（再验证）两个阶段

本地缓存，以资源的 url 为唯一索引，在用户第一次访问资源时，浏览器会将符合条件的文件添加到缓存池中。浏览器会优先从缓存池中检索，如果命中，则直接使用，否则从服务器上请求该文件。

cache-control (首部)

- no-store 不存储，即响应会禁止缓存对响应的拷贝
- no-cache 响应可以存储，但在与服务器进行新鲜度再验证之前，该缓存不能提供给客户端使用
- max-age 表示从响应回来时开始计数
  must-revalidate 必须进行新鲜度验证，在没有进行再验证的情况下，不能使用已过期的副本缓存。

协商缓存，当缓存文件到达缓存期限时，如果此时用户再次发起请求，但该文件其实并未发生变化，由于期限已到，不得不重写请求服务器，这样就造成了资源浪费，我们对这个阶段进行的优化操作，就称之为协商缓存。

- If-Modified-Since:< date > 如果从指定日期之后文档被修改过了，就执行请求的方法获取新的内容。与服务器响应首部 Last-Modified 配合使用。
- If-None-Match: ETag 服务器可以为文档提供特殊的标签（ETag），而不是将其与最近修改日期相匹配，这些标签就像序列号一样。如果已缓存标签与服务器文档中的标签有所不同，If-None-Match 首部就会执行请求的方法，获取新的内容。与服务器响应首部 ETag 配合使用。
